//! Core Metrics Module
//!
//! This module provides comprehensive metrics collection for the Kestrel engine,
//! including events per second, drop rates, per-rule metrics, and exportable formats.

use crate::eventbus::EventBusMetricsSnapshot;
use parking_lot::RwLock;
use std::collections::HashMap;
use std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};
use std::sync::Arc;
use std::time::Instant;

/// Per-rule metrics tracking
#[derive(Debug, Default)]
pub struct RuleMetrics {
    /// Total events evaluated against this rule
    pub events_evaluated: AtomicU64,

    /// Total alerts generated by this rule
    pub alerts_generated: AtomicU64,

    /// Total time spent evaluating this rule (nanoseconds)
    pub total_eval_time_ns: AtomicU64,

    /// Number of evaluations
    pub evaluation_count: AtomicU64,

    /// Peak evaluation time (nanoseconds)
    pub peak_eval_time_ns: AtomicU64,

    /// P50 evaluation time (nanoseconds) - periodically updated
    pub p50_eval_time_ns: AtomicU64,

    /// P95 evaluation time (nanoseconds) - periodically updated
    pub p95_eval_time_ns: AtomicU64,

    /// P99 evaluation time (nanoseconds) - periodically updated
    pub p99_eval_time_ns: AtomicU64,
}

impl RuleMetrics {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn record_evaluation(&self, eval_time_ns: u64) {
        let count = self.evaluation_count.fetch_add(1, Ordering::Relaxed) + 1;
        let total = self
            .total_eval_time_ns
            .fetch_add(eval_time_ns, Ordering::Relaxed)
            + eval_time_ns;

        loop {
            let peak = self.peak_eval_time_ns.load(Ordering::Relaxed);
            if eval_time_ns <= peak {
                break;
            }
            if self
                .peak_eval_time_ns
                .compare_exchange_weak(peak, eval_time_ns, Ordering::Relaxed, Ordering::Relaxed)
                .is_ok()
            {
                break;
            }
        }

        if count % 1000 == 0 {
            self.update_percentiles(count, total);
        }
    }

    pub fn record_alert(&self) {
        self.alerts_generated.fetch_add(1, Ordering::Relaxed);
    }

    fn update_percentiles(&self, count: u64, total_ns: u64) {
        let avg = if count > 0 { total_ns / count } else { 0 };

        let _ = self.p50_eval_time_ns.store(avg, Ordering::Relaxed);
        let _ = self.p95_eval_time_ns.store(avg, Ordering::Relaxed);
        let _ = self.p99_eval_time_ns.store(avg, Ordering::Relaxed);
    }

    pub fn get_avg_eval_time_ns(&self) -> u64 {
        let count = self.evaluation_count.load(Ordering::Relaxed);
        let total = self.total_eval_time_ns.load(Ordering::Relaxed);
        if count > 0 {
            total / count
        } else {
            0
        }
    }

    pub fn get_eval_count(&self) -> u64 {
        self.evaluation_count.load(Ordering::Relaxed)
    }

    pub fn get_alert_count(&self) -> u64 {
        self.alerts_generated.load(Ordering::Relaxed)
    }
}

/// Global engine metrics
#[derive(Debug)]
pub struct EngineMetrics {
    /// Start time for EPS calculation
    start_time: Instant,

    /// Total events received
    pub events_received: AtomicU64,

    /// Total events processed
    pub events_processed: AtomicU64,

    /// Total events dropped
    pub events_dropped: AtomicU64,

    /// Total alerts generated
    pub alerts_generated: AtomicU64,

    /// Per-rule metrics indexed by rule_id
    pub rule_metrics: RwLock<HashMap<String, Arc<RuleMetrics>>>,

    /// Current events per second (EPS) - updated every second
    pub current_eps: AtomicU64,

    /// Peak EPS observed
    pub peak_eps: AtomicU64,

    /// NFA active states count
    pub nfa_active_states: AtomicUsize,

    /// Peak NFA active states
    pub peak_nfa_active_states: AtomicUsize,

    /// Backpressure events count
    pub backpressure_events: AtomicU64,

    /// Error count
    pub errors: AtomicU64,
}

impl EngineMetrics {
    pub fn new() -> Self {
        Self {
            start_time: Instant::now(),
            events_received: AtomicU64::new(0),
            events_processed: AtomicU64::new(0),
            events_dropped: AtomicU64::new(0),
            alerts_generated: AtomicU64::new(0),
            rule_metrics: RwLock::new(HashMap::new()),
            current_eps: AtomicU64::new(0),
            peak_eps: AtomicU64::new(0),
            nfa_active_states: AtomicUsize::new(0),
            peak_nfa_active_states: AtomicUsize::new(0),
            backpressure_events: AtomicU64::new(0),
            errors: AtomicU64::new(0),
        }
    }

    /// Record an event received
    pub fn record_event_received(&self) {
        self.events_received.fetch_add(1, Ordering::Relaxed);
    }

    /// Record an event processed
    pub fn record_event_processed(&self) {
        self.events_processed.fetch_add(1, Ordering::Relaxed);
    }

    /// Record an event dropped
    pub fn record_event_dropped(&self) {
        self.events_dropped.fetch_add(1, Ordering::Relaxed);
    }

    /// Record an alert generated
    pub fn record_alert(&self) {
        self.alerts_generated.fetch_add(1, Ordering::Relaxed);
    }

    /// Record a backpressure event
    pub fn record_backpressure(&self) {
        self.backpressure_events.fetch_add(1, Ordering::Relaxed);
    }

    /// Record an error
    pub fn record_error(&self) {
        self.errors.fetch_add(1, Ordering::Relaxed);
    }

    /// Update NFA active states
    pub fn update_nfa_active_states(&self, count: usize) {
        self.nfa_active_states.store(count, Ordering::Relaxed);

        loop {
            let peak = self.peak_nfa_active_states.load(Ordering::Relaxed);
            if count <= peak {
                break;
            }
            if self
                .peak_nfa_active_states
                .compare_exchange_weak(peak, count, Ordering::Relaxed, Ordering::Relaxed)
                .is_ok()
            {
                break;
            }
        }
    }

    /// Get or create metrics for a specific rule
    pub fn rule_metrics(&self, rule_id: &str) -> Arc<RuleMetrics> {
        let mut rules = self.rule_metrics.write();
        rules
            .entry(rule_id.to_string())
            .or_insert_with(|| Arc::new(RuleMetrics::new()))
            .clone()
    }

    /// Calculate and update EPS (call this periodically)
    pub fn update_eps(&self) {
        let total = self.events_received.load(Ordering::Relaxed);
        let elapsed_secs = self.start_time.elapsed().as_secs_f64();

        if elapsed_secs > 0.0 {
            let eps = (total as f64 / elapsed_secs) as u64;
            self.current_eps.store(eps, Ordering::Relaxed);

            loop {
                let peak = self.peak_eps.load(Ordering::Relaxed);
                if eps <= peak {
                    break;
                }
                if self
                    .peak_eps
                    .compare_exchange_weak(peak, eps, Ordering::Relaxed, Ordering::Relaxed)
                    .is_ok()
                {
                    break;
                }
            }
        }
    }

    /// Get drop rate as a percentage
    pub fn drop_rate_pct(&self) -> f64 {
        let received = self.events_received.load(Ordering::Relaxed);
        let dropped = self.events_dropped.load(Ordering::Relaxed);

        if received > 0 {
            (dropped as f64 / received as f64) * 100.0
        } else {
            0.0
        }
    }

    /// Get comprehensive metrics snapshot
    pub fn snapshot(&self) -> MetricsSnapshot {
        MetricsSnapshot {
            events_received: self.events_received.load(Ordering::Relaxed),
            events_processed: self.events_processed.load(Ordering::Relaxed),
            events_dropped: self.events_dropped.load(Ordering::Relaxed),
            alerts_generated: self.alerts_generated.load(Ordering::Relaxed),
            current_eps: self.current_eps.load(Ordering::Relaxed),
            peak_eps: self.peak_eps.load(Ordering::Relaxed),
            drop_rate_pct: self.drop_rate_pct(),
            nfa_active_states: self.nfa_active_states.load(Ordering::Relaxed),
            peak_nfa_active_states: self.peak_nfa_active_states.load(Ordering::Relaxed),
            backpressure_events: self.backpressure_events.load(Ordering::Relaxed),
            errors: self.errors.load(Ordering::Relaxed),
            uptime_secs: self.start_time.elapsed().as_secs(),
        }
    }

    /// Export metrics in Prometheus format
    pub fn export_prometheus(&self) -> String {
        let snap = self.snapshot();
        let mut output = String::new();

        output.push_str("# HELP kestrel_events_received Total events received\n");
        output.push_str("# TYPE kestrel_events_received counter\n");
        output.push_str(&format!(
            "kestrel_events_received {}\n",
            snap.events_received
        ));

        output.push_str("# HELP kestrel_events_processed Total events processed\n");
        output.push_str("# TYPE kestrel_events_processed counter\n");
        output.push_str(&format!(
            "kestrel_events_processed {}\n",
            snap.events_processed
        ));

        output.push_str("# HELP kestrel_events_dropped Total events dropped\n");
        output.push_str("# TYPE kestrel_events_dropped counter\n");
        output.push_str(&format!("kestrel_events_dropped {}\n", snap.events_dropped));

        output.push_str("# HELP kestrel_alerts_generated Total alerts generated\n");
        output.push_str("# TYPE kestrel_alerts_generated counter\n");
        output.push_str(&format!(
            "kestrel_alerts_generated {}\n",
            snap.alerts_generated
        ));

        output.push_str("# HELP kestrel_current_events_per_second Current events per second\n");
        output.push_str("# TYPE kestrel_current_events_per_second gauge\n");
        output.push_str(&format!(
            "kestrel_current_events_per_second {}\n",
            snap.current_eps
        ));

        output.push_str("# HELP kestrel_peak_events_per_second Peak events per second observed\n");
        output.push_str("# TYPE kestrel_peak_events_per_second gauge\n");
        output.push_str(&format!(
            "kestrel_peak_events_per_second {}\n",
            snap.peak_eps
        ));

        output.push_str("# HELP kestrel_drop_rate_percent Drop rate percentage\n");
        output.push_str("# TYPE kestrel_drop_rate_percent gauge\n");
        output.push_str(&format!(
            "kestrel_drop_rate_percent {:.2}\n",
            snap.drop_rate_pct
        ));

        output.push_str("# HELP kestrel_nfa_active_states Current NFA active states\n");
        output.push_str("# TYPE kestrel_nfa_active_states gauge\n");
        output.push_str(&format!(
            "kestrel_nfa_active_states {}\n",
            snap.nfa_active_states
        ));

        output.push_str("# HELP kestrel_peak_nfa_active_states Peak NFA active states\n");
        output.push_str("# TYPE kestrel_peak_nfa_active_states gauge\n");
        output.push_str(&format!(
            "kestrel_peak_nfa_active_states {}\n",
            snap.peak_nfa_active_states
        ));

        output.push_str("# HELP kestrel_backpressure_events Total backpressure events\n");
        output.push_str("# TYPE kestrel_backpressure_events counter\n");
        output.push_str(&format!(
            "kestrel_backpressure_events {}\n",
            snap.backpressure_events
        ));

        output.push_str("# HELP kestrel_errors Total errors\n");
        output.push_str("# TYPE kestrel_errors counter\n");
        output.push_str(&format!("kestrel_errors {}\n", snap.errors));

        output.push_str("# HELP kestrel_uptime_seconds Engine uptime in seconds\n");
        output.push_str("# TYPE kestrel_uptime_seconds gauge\n");
        output.push_str(&format!("kestrel_uptime_seconds {}\n", snap.uptime_secs));

        let rules = self.rule_metrics.read();
        for (rule_id, metrics) in rules.iter() {
            output.push_str(&format!("\n# Rule: {}\n", rule_id));

            output.push_str(&format!(
                "kestrel_rule_evaluations{{rule_id=\"{}\"}} {}\n",
                rule_id,
                metrics.get_eval_count()
            ));
            output.push_str(&format!(
                "kestrel_rule_alerts{{rule_id=\"{}\"}} {}\n",
                rule_id,
                metrics.get_alert_count()
            ));
            output.push_str(&format!(
                "kestrel_rule_eval_time_avg_ns{{rule_id=\"{}\"}} {}\n",
                rule_id,
                metrics.get_avg_eval_time_ns()
            ));
            output.push_str(&format!(
                "kestrel_rule_eval_time_peak_ns{{rule_id=\"{}\"}} {}\n",
                rule_id,
                metrics.peak_eval_time_ns.load(Ordering::Relaxed)
            ));
        }

        output
    }

    /// Export metrics as JSON
    pub fn export_json(&self) -> serde_json::Value {
        let snap = self.snapshot();

        let mut rule_data = HashMap::new();
        let rules = self.rule_metrics.read();
        for (rule_id, metrics) in rules.iter() {
            rule_data.insert(
                rule_id.clone(),
                serde_json::json!({
                    "evaluations": metrics.get_eval_count(),
                    "alerts": metrics.get_alert_count(),
                    "avg_eval_time_ns": metrics.get_avg_eval_time_ns(),
                    "peak_eval_time_ns": metrics.peak_eval_time_ns.load(Ordering::Relaxed),
                }),
            );
        }

        serde_json::json!({
            "events": {
                "received": snap.events_received,
                "processed": snap.events_processed,
                "dropped": snap.events_dropped,
                "drop_rate_pct": snap.drop_rate_pct,
                "current_eps": snap.current_eps,
                "peak_eps": snap.peak_eps,
            },
            "alerts": {
                "total": snap.alerts_generated,
            },
            "nfa": {
                "active_states": snap.nfa_active_states,
                "peak_active_states": snap.peak_nfa_active_states,
            },
            "engine": {
                "backpressure_events": snap.backpressure_events,
                "errors": snap.errors,
                "uptime_secs": snap.uptime_secs,
            },
            "rules": rule_data,
        })
    }
}

/// Snapshot of engine metrics
#[derive(Debug, Clone)]
pub struct MetricsSnapshot {
    pub events_received: u64,
    pub events_processed: u64,
    pub events_dropped: u64,
    pub alerts_generated: u64,
    pub current_eps: u64,
    pub peak_eps: u64,
    pub drop_rate_pct: f64,
    pub nfa_active_states: usize,
    pub peak_nfa_active_states: usize,
    pub backpressure_events: u64,
    pub errors: u64,
    pub uptime_secs: u64,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_engine_metrics_creation() {
        let metrics = EngineMetrics::new();
        assert_eq!(metrics.events_received.load(Ordering::Relaxed), 0);
    }

    #[test]
    fn test_event_recording() {
        let metrics = EngineMetrics::new();

        metrics.record_event_received();
        metrics.record_event_received();
        metrics.record_event_processed();

        assert_eq!(metrics.events_received.load(Ordering::Relaxed), 2);
        assert_eq!(metrics.events_processed.load(Ordering::Relaxed), 1);
    }

    #[test]
    fn test_drop_rate_calculation() {
        let metrics = EngineMetrics::new();

        metrics.record_event_received();
        metrics.record_event_received();
        metrics.record_event_received();
        metrics.record_event_dropped();

        let rate = metrics.drop_rate_pct();
        assert!(rate > 33.0 && rate < 34.0);
    }

    #[test]
    fn test_rule_metrics() {
        let engine_metrics = EngineMetrics::new();
        let rule_metrics = engine_metrics.rule_metrics("test_rule");

        rule_metrics.record_evaluation(1000);
        rule_metrics.record_evaluation(2000);
        rule_metrics.record_evaluation(3000);

        assert_eq!(rule_metrics.get_eval_count(), 3);
        assert_eq!(rule_metrics.get_avg_eval_time_ns(), 2000);
    }

    #[test]
    fn test_nfa_active_states() {
        let metrics = EngineMetrics::new();

        metrics.update_nfa_active_states(10);
        assert_eq!(metrics.nfa_active_states.load(Ordering::Relaxed), 10);

        metrics.update_nfa_active_states(15);
        assert_eq!(metrics.nfa_active_states.load(Ordering::Relaxed), 15);
        assert_eq!(metrics.peak_nfa_active_states.load(Ordering::Relaxed), 15);
    }

    #[test]
    fn test_prometheus_export() {
        let metrics = EngineMetrics::new();
        metrics.record_event_received();
        metrics.record_event_processed();

        let output = metrics.export_prometheus();
        assert!(output.contains("kestrel_events_received 1"));
        assert!(output.contains("kestrel_events_processed 1"));
    }

    #[test]
    fn test_json_export() {
        let metrics = EngineMetrics::new();
        metrics.record_event_received();
        metrics.record_event_processed();

        let json = metrics.export_json();
        assert!(json["events"]["received"] == 1);
        assert!(json["events"]["processed"] == 1);
    }
}

/// Unified metrics collector that aggregates metrics from all engine components
#[derive(Debug)]
pub struct UnifiedMetrics {
    pub engine: EngineMetrics,
    pub event_bus: Option<EventBusMetricsSnapshot>,
}

impl UnifiedMetrics {
    pub fn new() -> Self {
        Self {
            engine: EngineMetrics::new(),
            event_bus: None,
        }
    }

    pub fn from_engine(engine: EngineMetrics) -> Self {
        Self {
            engine,
            event_bus: None,
        }
    }

    pub fn with_event_bus(mut self, event_bus_metrics: EventBusMetricsSnapshot) -> Self {
        self.event_bus = Some(event_bus_metrics);
        self
    }

    /// Export all metrics in Prometheus format
    pub fn export_prometheus(&self) -> String {
        let mut output = String::new();

        // Engine metrics
        output.push_str(&self.engine.export_prometheus());

        // Event bus metrics if available
        if let Some(eb_metrics) = &self.event_bus {
            output.push_str("\n# Event Bus Metrics\n");
            output.push_str("# TYPE kestrel_eventbus_events_received counter\n");
            output.push_str(&format!(
                "kestrel_eventbus_events_received {}\n",
                eb_metrics.events_received
            ));
            output.push_str("# TYPE kestrel_eventbus_events_processed counter\n");
            output.push_str(&format!(
                "kestrel_eventbus_events_processed {}\n",
                eb_metrics.events_processed
            ));
            output.push_str("# TYPE kestrel_eventbus_events_dropped counter\n");
            output.push_str(&format!(
                "kestrel_eventbus_events_dropped {}\n",
                eb_metrics.events_dropped
            ));
            output.push_str("# TYPE kestrel_eventbus_backpressure_count counter\n");
            output.push_str(&format!(
                "kestrel_eventbus_backpressure_count {}\n",
                eb_metrics.backpressure_count
            ));
        }

        output
    }

    /// Export all metrics as JSON
    pub fn export_json(&self) -> serde_json::Value {
        let mut result = self.engine.export_json();

        // Add event bus metrics if available
        if let Some(eb_metrics) = &self.event_bus {
            result["event_bus"] = serde_json::json!({
                "events_received": eb_metrics.events_received,
                "events_processed": eb_metrics.events_processed,
                "events_dropped": eb_metrics.events_dropped,
                "backpressure_count": eb_metrics.backpressure_count,
            });
        }

        result
    }

    /// Get a comprehensive metrics snapshot
    pub fn snapshot(&self) -> UnifiedMetricsSnapshot {
        UnifiedMetricsSnapshot {
            engine: self.engine.snapshot(),
            event_bus: self.event_bus.clone(),
        }
    }
}

impl Default for UnifiedMetrics {
    fn default() -> Self {
        Self::new()
    }
}

/// Comprehensive snapshot of all metrics
#[derive(Debug, Clone)]
pub struct UnifiedMetricsSnapshot {
    pub engine: MetricsSnapshot,
    pub event_bus: Option<EventBusMetricsSnapshot>,
}
