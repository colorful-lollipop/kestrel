// EQL Grammar for Kestrel

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }

// Identifiers and literals
identifier = @{ ('a'..'z' | 'A'..'Z') ~ ('a'..'z' | 'A'..'Z' | '0'..'9' | "_")* }
string_literal = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
int_literal = @{ '0'..'9'+ }

// Field references (e.g., process.executable, file.path)
field_ref = @{ identifier ~ ("." ~ identifier)* }

// Operators (longest first for proper matching)
comparison_op = { "!=" | "==" | "<=" | ">=" | "<" | ">" }
arithmetic_op = { "*" | "/" | "+" | "-" }  // * and / before + and - for proper parsing
and_op = { "and" | "&&" }
or_op = { "or" | "||" }
not_op = { "not" | "!" }

// Duration value (e.g., 5s, 10ms, 2m, 1h)
duration = @{ int_literal ~ ("ms" | "s" | "m" | "h") }

// Boolean literals
bool_literal = { "true" | "false" }

// Null literal (separate to avoid keyword conflicts)
null_literal = @{
    "null"
}

expr_list = {
    expr ~ ("," ~ expr)*
}

// Atom expressions (basic values)
atom = {
    bool_literal |
    int_literal |
    string_literal |
    null_literal |
    field_ref |
    "(" ~ expr ~ ")"
}

// Function calls
function_call = {
    identifier ~ "(" ~ expr_list ~ ")"
}

// In expression (must come before function_call to avoid ambiguity)
in_expr_atom = {
    atom ~ "in" ~ "(" ~ expr_list ~ ")"
}

// Array quantifier: any(array_field == value) or all(array_field > 0)
quantifier_expr = {
    ("any" | "all") ~ "(" ~ field_ref ~ comparison_op ~ expr ~ ")"
}

// Primary expression
primary = {
    quantifier_expr |
    function_call |
    in_expr_atom |
    atom
}

// Comparison expressions (left-assoc, allowing arithmetic on both sides)
arithmetic_expr = {
    primary ~ (arithmetic_op ~ primary)*
}

comparison_rhs = {
    comparison_op ~ arithmetic_expr ~ comparison_rhs?
}

comparison_expr = {
    arithmetic_expr ~ comparison_rhs?
}

// Logical NOT
not_expr = {
    not_op ~ comparison_expr |
    comparison_expr
}

// Logical AND (left-assoc)
and_expr = {
    not_expr ~ (and_op ~ not_expr)*
}

// Logical OR (left-assoc)
or_expr = {
    and_expr ~ (or_op ~ and_expr)*
}

// Top-level expression
expr = {
    or_expr
}

// Where clause
where_clause = {
    "where" ~ expr
}

// Event query: `process where process.executable == "/bin/bash"`
event_query = {
    identifier ~ where_clause?
}

// Sequence step: `[process where process.executable == "/bin/bash"]`
sequence_step = {
    "[" ~ identifier ~ where_clause? ~ "]"
}

// Maxspan clause
maxspan_clause = {
    "with" ~ "maxspan" ~ "=" ~ duration
}

// Until clause
until_clause = {
    "until" ~ sequence_step
}

// Sequence query
sequence_query = {
    "sequence" ~
    "by" ~ field_ref ~
    sequence_step+ ~
    maxspan_clause? ~
    until_clause?
}

// Top-level query
query = {
    SOI ~
    (sequence_query | event_query) ~
    EOI
}
